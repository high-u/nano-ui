<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Kanban - nanoui</title>
    <style>
      body {
        font-family: system-ui, -apple-system, sans-serif;
        margin: 20px;
      }
      h1 {
        font-size: 16px;
      }
      .controls {
        display: flex;
        gap: 20px;
        margin-bottom: 20px;
        flex-wrap: wrap;
      }
      .control-group {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      input, select {
        padding: 8px;
        font-size: 16px;
        border: 1px solid #ddd;
        border-radius: 4px;
      }
      button {
        padding: 8px 12px;
        font-size: 16px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }
      .add-btn {
        background-color: #333333;
        color: white;
      }
      .delete-btn {
        background-color: white;
        color: black;
        padding: 4px 12px;
        border: 1px solid #333333;
      }
      .move-btn {
        background-color: #333333;
        color: white;
        font-size: 12px;
        padding: 4px 12px;
        border: 1px solid #333333;
      }
      .board {
        display: flex;
        gap: 16px;
        overflow-x: auto;
        padding-bottom: 16px;
      }
      .lane {
        min-width: 250px;
        background-color: #f5f5f5;
        border-radius: 8px;
        padding: 12px;
      }
      .lane-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 12px;
        padding-bottom: 8px;
        border-bottom: 2px solid #ddd;
      }
      .lane-title {
        font-weight: bold;
        font-size: 16px;
      }
      .lane-delete-btn {
        background-color: white;
        color: black;
        padding: 4px 12px;
        font-size: 12px;
        border: 1px solid #333333;
      }
      .task-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .task {
        background-color: white;
        padding: 12px;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      }
      .task-name {
        margin-bottom: 8px;
      }
      .task-buttons {
        display: flex;
        gap: 4px;
      }
      .hidden {
        display: none;
      }
    </style>
  </head>
  <body>
    <h1>KANBAN</h1>
  </body>
  <script type="module">
    import { tags, render } from '../src/nanoui-v2.js';
    const { div, span, button, input, select } = tags;

    // State
    let lanes = [
      { id: 0, name: 'ToDo', tasks: [] },
      { id: 1, name: 'Progress', tasks: [] },
      { id: 2, name: 'Done', tasks: [] }
    ];
    let laneId = 3;
    let maxTaskId = 0;

    // Containers
    const board = div({ id: 'board', class: 'board' });

    // Lane input
    const laneInput = input({
      id: 'lane-input',
      type: 'text',
      placeholder: 'レーン名...'
    });

    // Lane add button
    const laneAddBtn = button({
      id: 'lane-add-btn',
      class: 'add-btn',
      onClick: () => addLane()
    }, 'レーン追加');

    // Task input
    const taskInput = input({
      id: 'task-input',
      type: 'text',
      placeholder: 'タスク名...'
    });

    // Lane select dropdown
    const laneSelect = select({ id: 'lane-select' });

    // Task add button
    const taskAddBtn = button({
      id: 'task-add-btn',
      class: 'add-btn',
      onClick: () => addTask()
    }, 'タスク追加');

    // Controls
    const controls = div({ id: 'controls', class: 'controls' },
      div({ id: 'lane-controls', class: 'control-group' },
        laneInput,
        laneAddBtn
      ),
      div({ id: 'task-controls', class: 'control-group' },
        taskInput,
        laneSelect,
        taskAddBtn
      )
    );

    // Create task element
    function createTaskElement(task, laneIndex, lanesArray) {
      const isFirst = laneIndex === 0;
      const isLast = laneIndex === lanesArray.length - 1;

      return div({ 'data-key': `task-${task.id}`, class: 'task' },
        div({ 'data-key': `task-name-${task.id}`, class: 'task-name' }, task.name),
        div({ 'data-key': `task-buttons-${task.id}`, class: 'task-buttons' },
          button({
            'data-key': `task-left-${task.id}`,
            class: `move-btn ${isFirst ? 'hidden' : ''}`,
            onClick: () => moveTask(task.id, -1, lanesArray)
          }, '<'),
          button({
            'data-key': `task-right-${task.id}`,
            class: `move-btn ${isLast ? 'hidden' : ''}`,
            onClick: () => moveTask(task.id, 1, lanesArray)
          }, '>'),
          button({
            'data-key': `task-delete-${task.id}`,
            class: `delete-btn ${!isFirst && !isLast ? 'hidden' : ''}`,
            onClick: () => deleteTask(task.id, lanesArray)
          }, 'x')
        )
      );
    }

    // Create lane element
    function createLaneElement(lane, lanesArray) {
      const laneIndex = lanesArray.findIndex(l => l.id === lane.id);

      return div({ 'data-key': `lane-${lane.id}`, class: 'lane' },
        div({ 'data-key': `lane-header-${lane.id}`, class: 'lane-header' },
          span({ 'data-key': `lane-title-${lane.id}`, class: 'lane-title' }, lane.name),
          button({
            'data-key': `lane-delete-${lane.id}`,
            class: 'lane-delete-btn',
            onClick: () => deleteLane(lane.id, lanesArray)
          }, '削除')
        ),
        div({ 'data-key': `lane-tasks-${lane.id}`, class: 'task-list' },
          ...lane.tasks.map(task => createTaskElement(task, laneIndex, lanesArray))
        )
      );
    }

    // Delete task
    function deleteTask(id, lanesArray) {
      lanesArray.forEach(lane => {
        lane.tasks = lane.tasks.filter(t => t.id !== id);
      });
      renderBoard(lanesArray);
    }

    // Move task to adjacent lane
    function moveTask(taskId, direction, lanesArray) {
      let task = null;
      let currentLaneIndex = -1;

      // Find task and current lane
      for (let i = 0; i < lanesArray.length; i++) {
        const foundTask = lanesArray[i].tasks.find(t => t.id === taskId);
        if (foundTask) {
          task = foundTask;
          currentLaneIndex = i;
          break;
        }
      }

      if (!task || currentLaneIndex === -1) return;

      const newLaneIndex = currentLaneIndex + direction;

      if (newLaneIndex < 0 || newLaneIndex >= lanesArray.length) return;

      // Remove task from current lane
      lanesArray[currentLaneIndex].tasks = lanesArray[currentLaneIndex].tasks.filter(t => t.id !== taskId);

      // Add task to new lane at beginning
      lanesArray[newLaneIndex].tasks.unshift(task);

      renderBoard(lanesArray);
    }

    // Delete lane
    function deleteLane(id, lanesArray) {
      const index = lanesArray.findIndex(l => l.id === id);
      if (index !== -1) {
        lanesArray.splice(index, 1);
      }
      updateLaneSelect();
      renderBoard(lanesArray);
    }

    // Renderer
    const renderBoard = render(
      board, 
      (lanesArray) => {
        return lanesArray.map(lane => createLaneElement(lane, lanesArray));
      }
    );

    // Update lane select options
    function updateLaneSelect() {
      laneSelect.innerHTML = '';
      lanes.forEach(lane => {
        const option = document.createElement('option');
        option.value = lane.id;
        option.textContent = lane.name;
        laneSelect.appendChild(option);
      });
    }

    // Add lane
    function addLane() {
      const name = laneInput.value.trim();
      if (!name) return;

      lanes.push({ id: laneId++, name, tasks: [] });
      laneInput.value = '';
      updateLaneSelect();
      renderBoard(lanes);
    }

    // Add task
    function addTask() {
      const name = taskInput.value.trim();
      if (!name || lanes.length === 0) return;

      const selectedLaneId = parseInt(laneSelect.value);
      const lane = lanes.find(l => l.id === selectedLaneId);
      if (!lane) return;

      lane.tasks.unshift({ id: ++maxTaskId, name });
      taskInput.value = '';
      renderBoard(lanes);
    }


    // Append to body
    document.body.append(controls, board);

    // 初期レンダリング
    updateLaneSelect();
    renderBoard(lanes);
  </script>
</html>
